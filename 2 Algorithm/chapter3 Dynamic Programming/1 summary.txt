Algorithm designed in "64-bits calculation" is hard to extend to the multiplication with longer number. It used logistic calculation to split an integer to two smaller integers whose length is no longer to 16 bits to avoid overflow. But a carry might appear in w+x and y+z and MUL(w+x, y+z) is likely to overflow. What's more, this implementation didn't have a addition that supports addition with numbers stored in array. 

The idea in high-precision multiplication is adopted to design "bigIntegerMul". Every segment of a number is limited to be shorter than 8 bits, and has the type of short to store the carry first. w+x and y+z has the longest length of 9-bits, requiring 18-bits at most to finish multiplication which is acceptable. ADDC and SUBB don't handle the carry; it will be handled after these calculations and before MUL returns by DOWN.
